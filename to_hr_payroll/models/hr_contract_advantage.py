from odoo import api, fields, models, _
from odoo.exceptions import UserError
from odoo.tools import float_compare


class HrContractAdvandage(models.Model):
    _name = 'hr.contract.advantage'
    _inherit = ['abstract.hr.advantage', 'mail.thread', 'mail.activity.mixin']
    _rec_name = 'template_id'
    _description = "Employee's Advantage on Contract"

    ##################################################################################################
    # every field of this model is accessible in salary rule Python code as advantages.CODE.field_name
    ##################################################################################################

    job_advantage_id = fields.Many2one('hr.job.advantage', string='Job Advantage', ondelete='restrict',
                                       compute='_compute_job_advantage', store=True, tracking=True)
    contract_id = fields.Many2one('hr.contract', string='Contract', required=True, ondelete='cascade', tracking=True)
    company_id = fields.Many2one(related='contract_id.company_id', store=True, tracking=True)
    currency_id = fields.Many2one(related='contract_id.currency_id', store=True, tracking=True)
    template_id = fields.Many2one('hr.advantage.template', string='Advantage', required=True, ondelete='restrict', tracking=True)
    code = fields.Char(related='template_id.code', index=True, tracking=True)
    amount = fields.Monetary(compute='_compute_amount', store=True, readonly=False, tracking=True)
    included_in_payroll_contribution_register = fields.Boolean(compute='_compute_included_in_payroll_contribution_register',
                                                               store=True, readonly=False,
                                                               help="If enabled, base amount of the corresponding"
                                                               " contribution register generated by this contract"
                                                               " will include the amount of this advantage.")
    # Override `based_on_time_off_type_id` field
    based_on_time_off_type_id = fields.Many2one(compute="_compute_based_on_time_off_type_id", store=True, readonly=False)

    _sql_constraints = [
        ('name_template_id',
         'UNIQUE(template_id,contract_id)',
         "The advantage must be unique per contract!"),
    ]

    @api.constrains('template_id', 'amount', 'currency_id')
    def _check_amount(self):
        for r in self:
            if not r.template_id:
                continue
            if float_compare(r.amount, r.template_id.lower_bound, precision_rounding=r.currency_id.rounding) == -1:
                raise UserError(_("You cannot specify an amount that is less than the Lower Bound of the template %s") % r.template_id.name)
            if float_compare(r.amount, r.template_id.upper_bound, precision_rounding=r.currency_id.rounding) == 1:
                raise UserError(_("You cannot specify an amount that is greater than the Upper Bound of the template %s") % r.template_id.name)

    @api.depends('contract_id.job_id', 'template_id')
    def _compute_job_advantage(self):
        for r in self:
            if r.contract_id and r.contract_id.job_id and r.template_id:
                job_advantages = r.contract_id.job_id.advantage_ids.filtered(lambda adv: adv.template_id == r.template_id)
                r.job_advantage_id = job_advantages and job_advantages[0] or False
            else:
                r.job_advantage_id = False

    @api.depends('job_advantage_id', 'template_id')
    def _compute_based_on_time_off_type_id(self):
        for r in self:
            if r.job_advantage_id.based_on_time_off_type_id:
                r.based_on_time_off_type_id = r.job_advantage_id.based_on_time_off_type_id
            else :
                r.based_on_time_off_type_id = r.template_id.based_on_time_off_type_id

    @api.depends('job_advantage_id', 'template_id')
    def _compute_amount(self):
        for r in self:
            if r.job_advantage_id:
                r.amount = r.job_advantage_id.amount
            elif r.template_id:
                r.amount = r.template_id.amount
            else:
                r.amount = 0.0

    @api.depends('template_id')
    def _compute_included_in_payroll_contribution_register(self):
        for r in self:
            r.included_in_payroll_contribution_register = r.template_id.included_in_payroll_contribution_register


