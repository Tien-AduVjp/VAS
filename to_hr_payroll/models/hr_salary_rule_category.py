from odoo import api, fields, models, _
from odoo.exceptions import ValidationError


class HrSalaryRuleCategory(models.Model):
    _name = 'hr.salary.rule.category'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _description = 'Salary Rule Category'

    name = fields.Char(required=True, translate=True, tracking=True)
    code = fields.Char(required=True, tracking=True)
    parent_id = fields.Many2one('hr.salary.rule.category', string='Parent', tracking=True,
        domain="['|', ('company_id','=',False), ('company_id','=',company_id)]",
        help="Linking a salary category to its parent is used only for the reporting purpose.")
    children_ids = fields.One2many('hr.salary.rule.category', 'parent_id', string='Children')
    note = fields.Text(string='Description')
    company_id = fields.Many2one('res.company', string='Company', required=True, default=lambda self: self.env.company,
                                 tracking=True, ondelete='cascade')
    paid_by_company = fields.Boolean(string='Paid by Company', tracking=True,
                                     help="If checked, amount generated by the rules of this category will be considered as company cost.")
    salary_rule_ids = fields.One2many('hr.salary.rule', 'category_id', string='Salary Rules',
                                      help="The salary rules that directly belong to this category")
    salary_rules_count = fields.Integer(string='Salary Rules Count', compute='_compute_salary_rules_count')

    _sql_constraints = [
        ('code_unique_per_company',
         'UNIQUE(code, company_id)',
         "The salary category code must be unique per company!"),
    ]

    def copy(self, default=None):
        self.ensure_one()
        default = dict(default or {}, name=_("%s (copy)") % self.name, code=_("%s_COPY") % self.code)
        return super(HrSalaryRuleCategory, self).copy(default)

    @api.constrains('parent_id')
    def _check_parent_id(self):
        if not self._check_recursion():
            raise ValidationError(_('Error! You cannot create recursive hierarchy of Salary Rule Category.'))

    def _compute_salary_rules_count(self):
        rules_data = self.env['hr.salary.rule'].read_group([('category_id', 'in', self.ids)], ['category_id'], ['category_id'])
        mapped_data = dict([(dict_data['category_id'][0], dict_data['category_id_count']) for dict_data in rules_data])
        for r in self:
            r.salary_rules_count = mapped_data.get(r.id, 0)

    def _sum_salary_rule(self, localdict, amount):
        """
        Summarize salary rules of this category
        :param localdict: a dictionary containing tools that will be available for salary rule computation and previous salary rule computation result. Here is a sample
            dict: {
                'datetime': Python module 'datetime' from '/usr/lib/python3.6/datetime.py'>,
                'dateutil': <module 'dateutil' from '/usr/local/lib/python3.6/dist-packages/dateutil/__init__.py'>,
                'fields': <module 'odoo.fields' from '/path/to/odoo_root/odoo/fields.py'>,
                'categories': <odoo.addons.to_hr_payroll.models.browsable_object.BrowsableObject object at 0x7f930616a390>,
                'rules': <odoo.addons.to_hr_payroll.models.browsable_object.BrowsableObject object at 0x7f9305ff7cc0>,
                'payslip': <odoo.addons.to_hr_payroll.models.browsable_object.Payslips object at 0x7f9305ff76d8>,
                'worked_days': <odoo.addons.to_hr_payroll.models.browsable_object.WorkedDays object at 0x7f93062fd278>,
                'advantages': <odoo.addons.to_hr_payroll.models.browsable_object.Advantages object at 0x7f9306396198>,
                'inputs': <odoo.addons.to_hr_payroll.models.browsable_object.InputLine object at 0x7f9306396128>,
                'contributions': <odoo.addons.to_hr_payroll.models.browsable_object.PayslipContributionLine object at 0x7f93063969b0>,
                'employee': hr.employee(10,),
                'contract': hr.contract(8,),
                'result': 4200.0,
                'result_qty': 1.0,
                'result_rate': 100,
                '__builtins__': {
                    '__import__': <function _import at 0x7f93110cd840>,
                    'True': True,
                    'False': False,
                    'None': None,
                    'bytes': <class 'bytes'>,
                    'str': <class 'str'>,
                    'unicode': <class 'str'>,
                    'bool': <class 'bool'>,
                    'int': <class 'int'>,
                    'float': <class 'float'>,
                    'enumerate': <class 'enumerate'>,
                    'dict': <class 'dict'>,
                    'list': <class 'list'>,
                    'tuple': <class 'tuple'>,
                    'map': <class 'map'>,
                    'abs': <built-in function abs>,
                    'min': <built-in function min>,
                    'max': <built-in function max>,
                    'sum': <built-in function sum>,
                    'reduce': <built-in function reduce>,
                    'filter': <class 'filter'>,
                    'round': <built-in function round>,
                    'len': <built-in function len>,
                    'repr': <built-in function repr>,
                    'set': <class 'set'>,
                    'all': <built-in function all>,
                    'any': <built-in function any>,
                    'ord': <built-in function ord>,
                    'chr': <built-in function chr>,
                    'divmod': <built-in function divmod>,
                    'isinstance': <built-in function isinstance>,
                    'range': <class 'range'>,
                    'xrange': <class 'range'>,
                    'zip': <class 'zip'>,
                    'Exception': <class 'Exception'>},
                'BASIC': 4200.0
                }
        :return: manipulated localdict
        """
        if self.parent_id:
            localdict = self.parent_id._sum_salary_rule(localdict, amount)
        localdict['categories'].dict[self.code] = self.code in localdict['categories'].dict and localdict['categories'].dict[self.code] + amount or amount
        return localdict

    def action_view_salary_rules(self):
        self.ensure_one()
        action = self.env.ref('to_hr_payroll.action_salary_rule_form')
        result = action.read()[0]

        salary_rules = self.mapped('salary_rule_ids')
        rules_count = len(salary_rules)

        # reset context
        result['context'] = {}
        # choose the view_mode accordingly
        if rules_count != 1:
            result['domain'] = "[('id', 'in', " + str(salary_rules.ids) + ")]"
        elif rules_count == 1:
            res = self.env.ref('to_hr_payroll.hr_salary_rule_form', False)
            result['views'] = [(res and res.id or False, 'form')]
            result['res_id'] = salary_rules.id
        return result

    def _get_name(self):
        return '%s (%s)' % (self.name, self.code)

    def name_get(self):
        result = []
        for r in self:
            result.append((r.id, r._get_name()))
        return result

    @api.model
    def name_search(self, name, args=None, operator='ilike', limit=100):
        args = args or []
        domain = []
        if name:
            domain = ['|', ('code', '=ilike', name + '%'), ('name', operator, name)]
        recs = self.search(domain + args, limit=limit)
        return recs.name_get()

