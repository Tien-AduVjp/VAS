from odoo import api, fields, models, _
from odoo.tools import float_is_zero, float_compare
from odoo.exceptions import UserError


class RepairFee(models.Model):
    _inherit = "repair.fee"

    task_id = fields.Many2one('project.task', 'Task', index=True, help="Task generated by the repair order fee line")
    is_service = fields.Boolean("Is a Service", compute='_compute_is_service', store=True, compute_sudo=True, help="Repair order fee line should generate a task and/or a project, depending on the product settings.")
    qty_delivered = fields.Float(string='Delivered', readonly=True, copy=False, digits='Product Unit of Measure', default=0.0)
    qty_to_invoice = fields.Float(
        compute='_get_to_invoice_qty', string='To Invoice', store=True, readonly=True,
        digits='Product Unit of Measure')
    qty_invoiced = fields.Float(
        compute='_get_invoice_qty', string='Invoiced Quantity', store=True, readonly=True,
        digits='Product Unit of Measure')
    invoice_lines = fields.Many2many('account.move.line', 'repair_fee_line_invoice_rel', 'repair_fee_line_id', 'invoice_line_id', string='Invoice Lines', copy=False)
    invoice_status = fields.Selection([
        ('invoiced', 'Fully Invoiced'),
        ('to invoice', 'To Invoice'),
        ('no', 'Nothing to Invoice')
        ], string='Invoice Status', compute='_compute_invoice_status', store=True, readonly=True, default='no')

    @api.depends('repair_id.state', 'repair_id.create_invoice', 'product_uom_qty', 'qty_delivered', 'qty_to_invoice', 'qty_invoiced')
    def _compute_invoice_status(self):
        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
        for r in self:
            if r.repair_id.state in ('draft', 'cancel') or not r.repair_id.create_invoice:
                r.invoice_status = 'no'
            elif not float_is_zero(r.qty_to_invoice, precision_digits=precision):
                r.invoice_status = 'to invoice'
            elif float_compare(r.qty_invoiced, r.product_uom_qty, precision_digits=precision) >= 0:
                r.invoice_status = 'invoiced'
            else:
                r.invoice_status = 'no'

    @api.depends('qty_invoiced', 'qty_delivered', 'product_uom_qty', 'repair_id.state')
    def _get_to_invoice_qty(self):
        for r in self:
            if r.repair_id.state not in ['draft', 'cancel']:
                if r.product_id.invoice_policy == 'order':
                    r.qty_to_invoice = r.product_uom_qty - r.qty_invoiced
                else:
                    r.qty_to_invoice = r.qty_delivered - r.qty_invoiced
            else:
                r.qty_to_invoice = 0

    @api.depends('invoice_lines.move_id.state', 'invoice_lines.quantity')
    def _get_invoice_qty(self):
        for r in self:
            qty_invoiced = 0.0
            for invoice_line in r.invoice_lines:
                if invoice_line.move_id.state != 'cancel':
                    if invoice_line.move_id.type == 'out_invoice':
                        qty_invoiced += invoice_line.product_uom_id._compute_quantity(invoice_line.quantity, r.product_uom)
                    elif invoice_line.move_id.type == 'out_refund':
                        qty_invoiced -= invoice_line.product_uom_id._compute_quantity(invoice_line.quantity, r.product_uom)
            r.qty_invoiced = qty_invoiced

    @api.depends('product_id.type')
    def _compute_is_service(self):
        for r in self:
            r.is_service = r.product_id.type == 'service'

    @api.model_create_multi
    def create(self, vals_list):
        records = super(RepairFee, self).create(vals_list)

        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
        # check ordered quantity to avoid create project/task when expensing service products
        records.filtered(lambda r: r.repair_id.state == 'confirmed' and not float_is_zero(r.product_uom_qty, precision_digits=precision))\
               ._timesheet_service_generation()
        return records

    ###########################################
    # ## Analytic : auto recompute delivered quantity
    ###########################################

#     def _timesheet_compute_delivered_quantity_domain(self):
#         # TODO JEM: avoid increment delivered for all AAL or just timesheet ?
#         # see nim commit https://github.com/odoo/odoo/commit/21fbb9776a5fbd1838b189f1f7cf8c5d40663e14
#         so_line_ids = self.filtered(lambda sol: sol.product_id.service_type != 'manual').ids
#         return ['&', ('so_line', 'in', so_line_ids), ('project_id', '!=', False)]
#
#     def _analytic_compute_delivered_quantity_domain(self):
#         domain = super(SaleOrderLine, self)._analytic_compute_delivered_quantity_domain()
#         timesheet_domain = self._timesheet_compute_delivered_quantity_domain()
#         return expression.OR([domain, timesheet_domain])

    ###########################################
    # # Service : Project and task generation
    ###########################################

    def _convert_qty_company_hours(self):
        company_time_uom_id = self.env.company.project_time_mode_id
        if self.product_uom.id != company_time_uom_id.id and self.product_uom.category_id.id == company_time_uom_id.category_id.id:
            planned_hours = self.product_uom._compute_quantity(self.product_uom_qty, company_time_uom_id)
        else:
            planned_hours = self.product_uom_qty
        return planned_hours

    def _timesheet_find_project(self):
        self.ensure_one()
        ProjectSudo = self.env['project.project'].sudo()
        project = self.product_id.project_id
        if not project:
            # find the project corresponding to the analytic account of the sales order
            account = self.repair_id.analytic_account_id
            if not account:
                self.repair_id._create_analytic_account(prefix=self.product_id.default_code or None)
                account = self.repair_id.analytic_account_id
            project = ProjectSudo.search([('analytic_account_id', '=', account.id)], limit=1)
            if not project:
                project_name = '%s (%s)' % (account.name, self.repair_id.partner_id.ref) if self.repair_id.partner_id.ref else account.name
                project = ProjectSudo.create({
                    'name': project_name,
                    'allow_timesheets': self.product_id.service_type == 'timesheet',
                    'analytic_account_id': account.id,
                    'company_id': self.repair_id.company_id.id
                })
                # set the repair line origin if product should create project
                if not project.repair_fee_line_id and self.product_id.service_tracking in ['task_in_project', 'project_only']:
                    project.write({'repair_fee_line_id': self.id})
        return project

    def _timesheet_create_task_prepare_values(self):
        self.ensure_one()
        project = self._timesheet_find_project()
        planned_hours = self._convert_qty_company_hours()
        return {
            'name': '%s:%s' % (self.repair_id.name or '', self.name.split('\n')[0] or self.product_id.name),
            'planned_hours': planned_hours,
            'remaining_hours': planned_hours,
            'partner_id': self.repair_id.partner_id.id,
            'description': self.name + '<br/>',
            'project_id': project.id,
            'repair_fee_line_id': self.id,
            'company_id':self.env.company.id,
            'email_from': self.repair_id.partner_id.email,
            'user_id': False,  # force non assigned task, as created as sudo()
        }

    def _timesheet_create_task(self):
        """ Generate task for the given so line, and link it.

            :return a mapping with the so line id and its linked task
            :rtype dict
        """
        result = {}
        for r in self:
            # create task
            values = r._timesheet_create_task_prepare_values()
            task = self.env['project.task'].sudo().create(values)
            r.write({'task_id': task.id})
            # post message on SO
            msg_body = _("Task Created (%s): <a href=# data-oe-model=project.task data-oe-id=%d>%s</a>") % (r.product_id.name, task.id, task.name)
            r.repair_id.message_post(body=msg_body)
            # post message on task
            task_msg = _("This task has been created from: <a href=# data-oe-model=sale.order data-oe-id=%d>%s</a> (%s)") % (r.repair_id.id, r.repair_id.name, r.product_id.name)
            task.message_post(body=task_msg)

            result[r.id] = task
        return result

    def _timesheet_find_task(self):
        """ Find the task generated by the so lines. If no task linked, it will be
            created automatically.

            :return a mapping with the so line id and its linked task
            :rtype dict
        """
        # one search for all so lines
        tasks = self.env['project.task'].search([('repair_fee_line_id', 'in', self.ids)])
        task_sol_mapping = {task.repair_fee_line_id.id: task for task in tasks}

        result = {}
        for r in self:
            # If the SO was confirmed, cancelled, set to draft then confirmed, avoid creating a new task.
            task = task_sol_mapping.get(r.id)
            # If not found, create one task for the so line
            if not task:
                task = r._timesheet_create_task()[r.id]
            result[r.id] = task
        return result

    def _timesheet_service_generation(self):
        """ For service lines, create the task or the project. If already exists, it simply links
            the existing one to the line.
        """
        for r in self.filtered(lambda x: x.is_service):
            # create task
            if r.product_id.service_tracking == 'task_global_project':
                r._timesheet_find_task()
            # create project
            if r.product_id.service_tracking == 'project_only':
                r._timesheet_find_project()
            # create project and task
            if r.product_id.service_tracking == 'task_in_project':
                r._timesheet_find_task()

    def _analytic_compute_delivered_quantity_domain(self):
        """ Return the domain of the analytic lines to use to recompute the delivered quantity
            on RO lines. This method is a hook: since analytic line are used for timesheet,
            expense, ...  each use case should provide its part of the domain.
        """
        return ['&', ('ro_line', 'in', self.ids), ('amount', '<=', 0.0)]

    def _analytic_compute_delivered_quantity(self):
        """ Compute and write the delivered quantity of current RO lines, based on their related
            analytic lines.
        """
        # avoid recomputation if no SO lines concerned
        if not self:
            return False

        # group anaytic lines by product uom and so line
        domain = self._analytic_compute_delivered_quantity_domain()
        data = self.env['account.analytic.line'].read_group(
            domain,
            ['ro_line', 'unit_amount', 'product_uom_id'], ['product_uom_id', 'ro_line'], lazy=False
        )
        # Force recompute for the "unlink last line" case: if remove the last AAL link to the SO, the read_group
        # will give no value for the qty of the SOL, so we need to reset it to 0.0
        value_to_write = {}
        if self._context.get('repair_analytic_force_recompute'):
            value_to_write = dict.fromkeys([rol for rol in self], 0.0)
        # convert uom and sum all unit_amount of analytic lines to get the delivered qty of SO lines
        for item in data:
            if not item['product_uom_id']:
                continue
            ro_line = self.browse(item['ro_line'][0])
            value_to_write.setdefault(ro_line, 0.0)
            uom = self.env['uom.uom'].browse(item['product_uom_id'][0])
            if ro_line.product_uom.category_id == uom.category_id:
                qty = uom._compute_quantity(item['unit_amount'], ro_line.product_uom)
            else:
                qty = item['unit_amount']
            value_to_write[ro_line] += qty

        # write the delivered quantity
        for ro_line, qty in value_to_write.items():
            ro_line.write({'qty_delivered': qty})

        return True

    def _prepare_invoice_line(self, qty):
        """
        Prepare the dict of values to create the new invoice line for a sales order line.

        :param qty: float quantity to invoice
        """
        self.ensure_one()
        account = self.product_id.property_account_income_id or self.product_id.categ_id.property_account_income_categ_id
        if not account:
            raise UserError(_('Please define income account for this product: "%s" (id:%d) - or for its category: "%s".') %
                (self.product_id.name, self.product_id.id, self.product_id.categ_id.name))

        balance = -(qty * self.price_unit)
        res = {
            'name': self.name,
            'account_id': account.id,
            'price_unit': self.price_unit,
            'quantity': qty,
            'product_uom_id': self.product_uom.id,
            'product_id': self.product_id.id or False,
            'tax_ids': [(6, 0, self.tax_id.ids)],
            'analytic_account_id': self.repair_id.analytic_account_id.id,
            'debit': balance > 0.0 and balance or 0.0,
            'credit': balance < 0.0 and -balance or 0.0,
        }

        return res

    def _prepare_invoice_lines_from_fees(self, invoice_id, qty):
        """ Create an invoice line. The quantity to invoice can be positive (invoice) or negative (refund).
            :param invoice_id: integer
            :param qty: float quantity to invoice
            :returns recordset of account.move.line created
        """
        invoice_lines_from_fees = []
        precision = self.env['decimal.precision'].precision_get('Product Unit of Measure')
        for r in self:
            if not float_is_zero(qty, precision_digits=precision):
                vals = r._prepare_invoice_line(qty=qty)
                vals.update({'move_id': invoice_id, 'repair_fee_line_ids': [(6, 0, [r.id])]})
                invoice_lines_from_fees.append(vals)
        return invoice_lines_from_fees
