from odoo import api, fields, models, _
from odoo.exceptions import UserError


class HrPayslip(models.Model):
    _inherit = 'hr.payslip'

    date = fields.Date('Accounting Date', readonly=False,
                       states={'verify': [('readonly', True)], 'done': [('readonly', True)], 'cancel': [('readonly', True)]},
                       compute='_compute_date', store=True,
                       help="Keep empty to use the period of the validation(Payslip) date.")
    journal_id = fields.Many2one('account.journal', 'Salary Journal', readonly=False, required=True,
        states={'verify': [('readonly', True)], 'done': [('readonly', True)], 'cancel': [('readonly', True)]},
        compute='_compute_journal_id', store=True, copy=True)
    move_id = fields.Many2one('account.move', 'Accounting Entry', readonly=True, copy=False)
    non_private_address_alert = fields.Char(compute='_compute_non_private_address_alert')

    def _compute_non_private_address_alert(self):
        for r in self:
            if r.employee_id and not r.employee_id.sudo().address_home_id:
                r.non_private_address_alert = _("There is no private address specified for the employee '%s'. Therefore,"
                                                " the account entries generated by this payslip will not address anyone.") % r.employee_id.name
            else:
                r.non_private_address_alert = ''

    @api.model_create_multi
    def create(self, vals_list):
        for vals in vals_list:
            if not vals.get('journal_id', False):
                vals['journal_id'] = self.env.context.get('journal_id') or self.env['hr.contract']._get_default_journal_id().id
        return super(HrPayslip, self).create(vals_list)

    @api.depends('payslip_run_id.date')
    def _compute_date(self):
        for r in self:
            dt = r.date or False
            if r.payslip_run_id:
                if r.payslip_run_id.date:
                    dt = r.payslip_run_id.date
                elif r.payslip_run_id.date_end:
                    dt = r.payslip_run_id.date_end
            r.date = dt

    @api.depends('contract_id')
    def _compute_journal_id(self):
        for r in self:
            if r.contract_id and r.contract_id.journal_id:
                r.journal_id = r.contract_id.journal_id
            else:
                r.journal_id = r.contract_id._get_default_journal_id()

    def action_payslip_cancel(self):
        move_lines = self.sudo().mapped('move_id.line_ids')

        # remove reconcile of the relines being partial or full reconciled if the user has accountant access right.
        # otherwise, raise an error
        reconciled_lines = move_lines.filtered(lambda l: l.reconciled or l.matched_debit_ids or l.matched_credit_ids)
        if reconciled_lines:
            if self.env.user.has_group('account.group_account_user'):
                reconciled_lines.remove_move_reconcile()
            else:
                raise UserError(_("You cannot cancel the payslips having full or partial reconciled accounting journal entries. Please"
                                  " ask someone who has Accountant access rights for help removing reconciliation for the following"
                                  " accounting entries first.\n%s")
                                  % ', '.join(reconciled_lines.mapped('move_id.display_name')))

        # cancel the related account moves
        moves = self.sudo().mapped('move_id')
        moves.filtered(lambda x: x.state == 'posted').button_cancel()
        moves.with_context(force_delete=True).unlink()
        return super(HrPayslip, self).action_payslip_cancel()

    def _prepare_account_move_data(self):
        self.ensure_one()
        name = _('Payslip of %s') % (self.employee_id.name)
        date = self.date or self.date_to
        return {
            'narration': name,
            'ref': self.number,
            'journal_id': self.journal_id.id,
            'date': date,
            'line_ids': [(0, 0, vals) for vals in self.details_by_salary_rule_category._prepare_account_move_lines_data()],
            'auto_post': True if date > fields.Date.today() else False,
            }

    def action_payslip_verify(self):
        res = super(HrPayslip, self).action_payslip_verify()
        if not self._context.get('ignore_payslip_account_move_generation', False):
            self._compute_details_by_salary_rule_category()
            for slip in self:
                if not slip.payslip_run_id or (slip.payslip_run_id and not slip.company_id.payslip_batch_journal_entry):
                    move_data = slip._prepare_account_move_data()
                    if not move_data['line_ids']:
                        continue
                    move = self.env['account.move'].sudo().create(move_data)
                    slip.write({'move_id': move.id, 'date': slip.date or slip.date_to})
                elif slip.company_id.payslip_batch_journal_entry:
                    raise UserError(_("Direct verifying a payslip belong to a batch is not allowed."
                                      " Please validate the corresponding payslip batch instead."))

        # sudo must be used to avoid access right problem
        related_account_moves = self.mapped('payslip_run_id.move_id')
        related_account_moves |= self.mapped('move_id')
        related_account_moves = related_account_moves.sudo().filtered(lambda m: m.state == 'draft' and not m.auto_post)
        if related_account_moves:
            related_account_moves._post(soft=True)
        return res
